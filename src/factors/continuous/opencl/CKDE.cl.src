/* This code assumes column major data for matrices. */

#define IDX(i, j, rows) (i) + ((j)*(rows))
#define ROW(idx, rows) (idx) % (rows)
#define COL(idx, rows) (idx) / (rows)

#define MAX_ASSIGN(n1, n2) n1 = max((n1), (n2))
#define SUM_ASSIGN(n1, n2) n1 += (n2)

/**begin repeat
 * #dt = double, float#
 */

__kernel void logpdf_values_1d_@dt@(__constant @dt@ *train_vector,
                                    __constant @dt@ *test_vector,
                                    __private uint test_index,
                                    __constant @dt@ *standard_deviation,
                                    __private @dt@ lognorm_factor,
                                    __global @dt@ *result) 
{
    int i = get_global_id(0);
    @dt@ d = (train_vector[i] - test_vector[test_index]) / standard_deviation[0];
    result[i] = (-0.5*d*d) + lognorm_factor;
}

__kernel void logpdf_values_1d_matrix_@dt@(__constant @dt@ *train_vector,
                                           __private uint train_rows,
                                           __constant @dt@ *test_vector,
                                           __constant @dt@ *standard_deviation,
                                           __private @dt@ lognorm_factor,
                                           __global @dt@ *result) 
{
    int i = get_global_id(0);
    int train_idx = ROW(i, train_rows);
    int test_idx = COL(i, train_rows);
    @dt@ d = (train_vector[train_idx] - test_vector[test_idx]) / standard_deviation[0];

    result[i] = (-0.5*d*d) + lognorm_factor;
}



/**begin repeat1
 * #operation = max, sum#
 * #operation_macro = MAX_ASSIGN, SUM_ASSIGN#
 */

__kernel void @operation@1d_@dt@(__constant @dt@ *input,
                                      __private uint input_length,
                                      __local @dt@ *localMaxs,
                                      __global @dt@ *output,
                                      __private uint output_offset)
{
    uint global_id = get_global_id(0);
    uint local_id = get_local_id(0);
    uint group_size = get_local_size(0);
    uint group_id = get_group_id(0);
    uint num_groups = get_num_groups(0);

    if (group_id == num_groups-1) {
        group_size = input_length - group_id*group_size;

        if (global_id < input_length) {
            localMaxs[local_id] = input[global_id];
        }
    }
    else {
        localMaxs[local_id] = input[global_id];
    }

    while (group_size > 1) {
        int stride = group_size / 2;
        barrier(CLK_LOCAL_MEM_FENCE);
        if (group_size % 2 == 0) {
            if (local_id < stride) {
                @operation_macro@(localMaxs[local_id], localMaxs[local_id + stride]);
            }

            group_size = group_size / 2;
        }
        else {
            if (local_id < stride) {
                @operation_macro@(localMaxs[local_id + 1], localMaxs[local_id + 1 + stride]);
            }
            group_size = (group_size / 2) + 1;
        }
    }

    if (local_id == 0) {
        output[output_offset + group_id] = localMaxs[0];
    }
}

__kernel void @operation@_mat_cols_@dt@(__constant @dt@ *mat,
                                             __private uint mat_rows,
                                             __local @dt@ *localMaxs,
                                             __global @dt@ *output)
{
    uint global_id_row = get_global_id(0);
    uint global_id_col = get_global_id(1);
    uint local_id = get_local_id(0);
    uint group_size = get_local_size(0);
    uint group_id = get_group_id(0);
    uint num_groups = get_num_groups(0);


    if (group_id == num_groups-1) {
        group_size = mat_rows - group_id*group_size;

        if (global_id_row < mat_rows) {
            localMaxs[local_id] = mat[IDX(global_id_row, global_id_col, mat_rows)];
        }
    }
    else {
        localMaxs[local_id] = mat[IDX(global_id_row, global_id_col, mat_rows)];
    }

    while (group_size > 1) {
        int stride = group_size / 2;
        barrier(CLK_LOCAL_MEM_FENCE);
        if (group_size % 2 == 0) {
            if (local_id < stride) {
                @operation_macro@(localMaxs[local_id], localMaxs[local_id + stride]);
            }
            group_size = group_size / 2;
        }
        else {
            if (local_id < stride) {
                @operation_macro@(localMaxs[local_id+1], localMaxs[local_id+1+stride]);
            }
            group_size = (group_size / 2) + 1;
        }
    }

    if (local_id == 0) {
        output[IDX(group_id, global_id_col, num_groups)] = localMaxs[0];
    }
}

__kernel void @operation@_mat_cols_offset_@dt@(__constant @dt@ *mat,
                                             __private uint mat_rows,
                                             __local @dt@ *localMaxs,
                                             __global @dt@ *output,
                                             __private uint output_offset)
{
    uint global_id_row = get_global_id(0);
    uint global_id_col = get_global_id(1);
    uint local_id = get_local_id(0);
    uint group_size = get_local_size(0);
    uint group_id = get_group_id(0);
    uint num_groups = get_num_groups(0);


    if (group_id == num_groups-1) {
        group_size = mat_rows - group_id*group_size;

        if (global_id_row < mat_rows) {
            localMaxs[local_id] = mat[IDX(global_id_row, global_id_col, mat_rows)];
        }
    }
    else {
        localMaxs[local_id] = mat[IDX(global_id_row, global_id_col, mat_rows)];
    }

    while (group_size > 1) {
        int stride = group_size / 2;
        barrier(CLK_LOCAL_MEM_FENCE);
        if (group_size % 2 == 0) {
            if (local_id < stride) {
                @operation_macro@(localMaxs[local_id], localMaxs[local_id + stride]);
            }
            group_size = group_size / 2;
        }
        else {
            if (local_id < stride) {
                @operation_macro@(localMaxs[local_id+1], localMaxs[local_id+1+stride]);
            }
            group_size = (group_size / 2) + 1;
        }
    }

    if (local_id == 0) {
        output[IDX(group_id, output_offset + global_id_col, num_groups)] = localMaxs[0];
    }
}

/**end repeat1**/


__kernel void logsumexp_coeffs_@dt@(__global @dt@ *input,
                                    __constant @dt@ *max,
                                    __private uint max_offset) {
    uint idx = get_global_id(0);
    input[idx] = exp(input[idx] - max[max_offset]);
}

__kernel void logsumexp_coeffs_mat_@dt@(__global @dt@ *input,
                                        __private uint input_rows,
                                        __constant @dt@ *max) {
    uint idx = get_global_id(0);
    uint col = COL(idx, input_rows);
    input[idx] = exp(input[idx] - max[col]);
}

__kernel void copy_logpdf_result_@dt@(__constant @dt@ *sum,
                                      __private uint sum_offset,
                                      __constant @dt@ *max,
                                      __private uint max_offset,
                                      __global @dt@ *res,
                                      __private uint res_offset) {
    res[res_offset] = max[max_offset] + log(sum[sum_offset]);
}

__kernel void maxwise_@dt@(__global @dt@ *max_buffer,
                            __constant @dt@ *other) {
    uint i = get_global_id(0);
    max_buffer[i] = max(max_buffer[i], other[i]);
}

__kernel void sum_lse_coefficient_@dt@(__constant @dt@ *logpdf, __constant @dt@ *max_vec, __global @dt@ *lse_total) {
    uint idx = get_global_id(0);
    lse_total[idx] += exp(logpdf[idx] - max_vec[idx]);
}

__kernel void finish_lse_@dt@(__global @dt@ *res, __constant @dt@ *max_vec) {
    uint idx = get_global_id(0);
    res[idx] = log(res[idx]) + max_vec[idx];
}


__kernel void substract_matrix_@dt@(__constant @dt@ *training_matrix,
                                        __private uint training_rows,
                                        __constant @dt@ *test_matrix,
                                        __private uint test_rows,
                                        __private uint test_row_idx,
                                        __global @dt@ *res
                                )
{
    int i = get_global_id(0);

    int r = ROW(i, training_rows);
    int c = COL(i, training_rows);

    res[i] = test_matrix[IDX(test_row_idx, c, test_rows)] - training_matrix[i];
}


__kernel void solve_@dt@(__global @dt@ *diff_matrix, 
                        __private uint diff_matrix_rows, 
                        __private uint matrices_cols,
                        __constant @dt@ *cholesky_matrix) {
    uint r = get_global_id(0);
    
    for (uint c = 0; c < matrices_cols; c++) {
        for (uint i = 0; i < c; i++) {
            diff_matrix[IDX(r, c, diff_matrix_rows)] -= cholesky_matrix[IDX(c, i, matrices_cols)] * diff_matrix[IDX(r, i, diff_matrix_rows)];
        }
        diff_matrix[IDX(r, c, diff_matrix_rows)] /= cholesky_matrix[IDX(c, c, matrices_cols)];
    }
}

__kernel void square_@dt@(__global @dt@ *m) {
    uint idx = get_global_id(0);
    double d = m[idx];
    m[idx] = d * d;
}

__kernel void logpdf_values_@dt@(__constant @dt@ *square_data,
                                __private uint square_cols,
                                __global @dt@ *sol_vec,
                                __private @dt@ lognorm_factor) {
    uint sol_row = get_global_id(0);
    uint square_rows = get_global_size(0);

    sol_vec[sol_row] = square_data[IDX(sol_row, 0, square_rows)];
    for (uint i = 1; i < square_cols; i++) {
        sol_vec[sol_row] += square_data[IDX(sol_row, i, square_rows)];
    }

    sol_vec[sol_row] = (-0.5 * sol_vec[sol_row]) + lognorm_factor;
}


__kernel void logpdf_values_mat_@dt@(__constant @dt@ *square_data,
                                     __private uint square_cols,
                                     __global @dt@ *sol_mat,
                                     __private uint sol_rows,
                                     __private uint sol_row_idx,
                                     __private @dt@ lognorm_factor) {
    uint test_idx = get_global_id(0);
    uint square_rows = get_global_size(0);
    
    uint sol_idx = IDX(sol_row_idx, test_idx, sol_rows);
    sol_mat[sol_idx] = square_data[IDX(test_idx, 0, square_rows)];
    for (uint i = 1; i < square_cols; i++) {
        sol_mat[sol_idx] += square_data[IDX(test_idx, i, square_rows)];
    }

    sol_mat[sol_idx] = (-0.5 * sol_mat[sol_idx]) + lognorm_factor;
}


__kernel void logpdf_values_1d_mat_partial_@dt@(__constant @dt@ *train_vector,
                                           __private uint train_rows,
                                           __constant @dt@ *test_vector,
                                           __private uint test_offset,
                                           __constant @dt@ *standard_deviation,
                                           __private @dt@ lognorm_factor,
                                           __global @dt@ *result) 
{
    int i = get_global_id(0);
    int train_idx = ROW(i, train_rows);
    int test_idx = COL(i, train_rows);
    @dt@ d = (train_vector[train_idx] - test_vector[test_offset + test_idx]) / standard_deviation[0];

    result[i] = (-0.5*d*d) + lognorm_factor;
}

__kernel void substract_partial_@dt@(__constant @dt@ *training_matrix,
                                     __private uint training_physical_rows,
                                     __private uint training_offset,
                                     __private uint training_rows,
                                     __constant @dt@ *test_matrix,
                                     __private uint test_physical_rows,
                                     __private uint test_offset,
                                     __private uint test_row_idx,
                                     __global @dt@ *res
                                )
{
    uint i = get_global_id(0);
    uint r = ROW(i, training_rows) + training_offset;
    uint c = COL(i, training_rows);

    res[i] = test_matrix[IDX(test_offset + test_row_idx, c, test_physical_rows)] - training_matrix[IDX(r, c, training_physical_rows)];
}


__kernel void logpdf_values_mat_partial_column_@dt@(__constant @dt@ *square_data,
                                                    __private uint square_cols,
                                                    __global @dt@ *sol_mat,
                                                    __private uint sol_rows,
                                                    __private uint sol_col_idx,
                                                    __private @dt@ lognorm_factor) {
    uint test_idx = get_global_id(0);
    uint square_rows = get_global_size(0);
    
    uint sol_idx = IDX(test_idx, sol_col_idx, sol_rows);

    @dt@ summation = square_data[IDX(test_idx, 0, square_rows)];
    for (uint i = 1; i < square_cols; i++) {
        summation += square_data[IDX(test_idx, i, square_rows)];
    }

    sol_mat[sol_idx] = (-0.5 * summation) + lognorm_factor;
}

__kernel void logpdf_values_mat_partial_row_@dt@(__constant @dt@ *square_data,
                                                    __private uint square_cols,
                                                    __global @dt@ *sol_mat,
                                                    __private uint sol_rows,
                                                    __private uint sol_row_idx,
                                                    __private @dt@ lognorm_factor) {
    uint test_idx = get_global_id(0);
    uint square_rows = get_global_size(0);
    
    uint sol_idx = IDX(sol_row_idx, test_idx, sol_rows);

    @dt@ summation = square_data[IDX(test_idx, 0, square_rows)];
    for (uint i = 1; i < square_cols; i++) {
        summation += square_data[IDX(test_idx, i, square_rows)];
    }

    sol_mat[sol_idx] = (-0.5 * summation) + lognorm_factor;
}

__kernel void finish_lse_offset_@dt@(__global @dt@ *res, __private uint res_offset, __constant @dt@ *max_vec) {
    uint idx = get_global_id(0);
    res[idx + res_offset] = log(res[idx + res_offset]) + max_vec[idx];
}



// __kernel void logpdf_values_mat_partial_@dt@(__constant @dt@ *train_mat,
//                                            __constant @dt@ *test_mat,
//                                            __private uint test_offset,
//                                            __private uint test_physical_rows,
//                                            __constant @dt@ *cholesky,
//                                            __local @dt@ *cholesky_local,
//                                            __private @dt@ lognorm_factor,
//                                            __local @dt@ *local_instance,
//                                            __global @dt@ *result)
// {
//     int i = get_global_id(0);
//     int var_idx = get_global_id(2);
//     int num_vars = get_global_size(2);
//     int train_idx = get_global_id(0);
//     int train_rows = get_global_size(0);
//     int test_idx = get_global_id(1);

//     local_instance[var_idx] = train_mat[IDX(train_idx, var_idx, train_rows)] - test_mat[IDX(test_offset + test_idx, var_idx, test_physical_rows)];


//     for (int c = 0; c <= var_idx; ++c) {
//         cholesky_local[IDX(var_idx, c, num_vars)] = cholesky[IDX(var_idx, c, num_vars)];
//     }


//     if (var_idx == 0) {
//         barrier(CLK_LOCAL_MEM_FENCE);
//         for (uint c = 0; c < num_vars; ++c) {
//             for (uint i = 0; i < c; ++i) {
//                 local_instance[c] -= cholesky_local[IDX(c, i, num_vars)] * local_instance[i];
//             }
//             local_instance[c] /= cholesky_local[IDX(c, c, num_vars)];
//         }
//     }

//     barrier(CLK_LOCAL_MEM_FENCE);
//     local_instance[var_idx] *= local_instance[var_idx];

//     barrier(CLK_LOCAL_MEM_FENCE);
//     if (var_idx == 0) {
//         for(uint c = 1; c < num_vars; ++c) {
//             local_instance[0] += local_instance[c];
//         }

//         local_instance[0] = (-0.5 * local_instance[0]) + lognorm_factor;
//         result[IDX(train_idx, test_idx, train_rows)] = local_instance[0];
//     }
// }







/**end repeat**/
